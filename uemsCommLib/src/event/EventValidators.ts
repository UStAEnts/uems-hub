// Generated by gen.mjs @ 2022-07-06T14:30:52.824Z - avoid editing this file by hand! 
import * as zod from 'zod';
import { BaseSchema } from '../BaseSchema';
import { ZodValidator } from '../messaging/MessageValidator';
import { VenueValidators } from "../venues/VenueValidators";
import { EntStateValidators } from "../ent/EntStateValidators";
import { UserValidators } from "../user/UserValidators";
import { StateValidators } from "../state/StateValidators";

export namespace EventValidators {

    import REQUEST_CORE_SCHEMA = BaseSchema.REQUEST_CORE_SCHEMA;
    import RESPONSE_CORE_SCHEMA = BaseSchema.RESPONSE_CORE_SCHEMA;
    import ZVenue = VenueValidators.ZVenue;
    import ZEntState = EntStateValidators.ZEntState;
    import ZUser = UserValidators.ZUser;
    import ZState = StateValidators.ZState;

    export const ZEvent = zod.object({
        id: zod.string()
            .describe("The unique ID for this event"),
        name: zod.string()
            .describe("The name of the event"),
        start: zod.number()
            .describe("The unix-second timestamp UTC when the event will begin"),
        end: zod.number()
            .describe("The unix-second UTC timestamp when the event finishes"),
        venues: zod.array(ZVenue)
            .describe("The venues in which this event takes place"),
        attendance: zod.number()
            .describe("The anticipated attendance of this event"),
        ents: ZEntState
            .optional()
            .describe("The ent state of this event"),
        state: ZState
            .optional()
            .describe("The state of this event approval"),
        author: ZUser
            .describe("The user who is running this event"),
        reserved: zod.boolean()
            .optional()
            .describe("If this space and time has been reserved for this event"),
    });
    export type EventRepresentation = zod.infer<typeof ZEvent>;
    export const ZEventShallow = zod.object({
        id: zod.string()
            .describe("The unique ID for this event"),
        name: zod.string()
            .describe("The name of the event"),
        start: zod.number()
            .describe("The unix-second timestamp UTC when the event will begin"),
        end: zod.number()
            .describe("The unix-second UTC timestamp when the event finishes"),
        venues: zod.array(zod.string())
            .describe("The venues in which this event takes place"),
        attendance: zod.number()
            .describe("The anticipated attendance of this event"),
        ents: zod.string()
            .describe("The ent state of this event"),
        state: zod.string()
            .describe("The state of this event approval"),
        author: zod.string()
            .describe("The user who is running this event"),
        reserved: zod.boolean()
            .optional()
            .describe("If this space and time has been reserved for this event"),
    });
    export type EventShallowRepresentation = zod.infer<typeof ZEventShallow>;
    export const ZEventRead = REQUEST_CORE_SCHEMA('READ').extend({
        id: zod.string().or(zod.array(zod.string()))
            .optional()
            .describe("The unique ID for this event"),
        name: zod.string()
            .optional()
            .describe("The name of the event"),
        start: zod.object({
            greater: zod.number(),
            less: zod.number(),
        }).or(zod.number())
            .optional()
            .describe("The unix-second timestamp UTC when the event will begin"),
        end: zod.object({
            greater: zod.number(),
            less: zod.number(),
        }).or(zod.number())
            .optional()
            .describe("The unix-second UTC timestamp when the event finishes"),
        venues: zod.array(zod.string())
            .optional()
            .describe("The venues in which this event takes place"),
        attendance: zod.object({
            greater: zod.number(),
            less: zod.number(),
        }).or(zod.number())
            .optional()
            .describe("The anticipated attendance of this event"),
        ents: zod.string()
            .optional()
            .describe("The ent state of this event"),
        state: zod.string()
            .optional()
            .describe("The state of this event approval"),
        author: zod.string()
            .optional()
            .describe("The user who is running this event"),
        reserved: zod.boolean()
            .optional()
            .describe("If this space and time has been reserved for this event"),
        coincidesWith: zod.object({
            start: zod.number()
                .describe("The start of the range"),
            end: zod.number()
                .describe("The end of the range"),
        })
            .optional()
            .describe("Finds events that overlap with this time range"),
        allVenues: zod.array(zod.string())
            .optional()
            .describe("All venues required to match an event"),
        anyVenues: zod.array(zod.string())
            .optional()
            .describe("Returns events where at least one venue is present"),
        stateIn: zod.array(zod.string())
            .optional()
            .describe("Returns events that have at least one state in the given range"),
    });
    export type EventRead = zod.infer<typeof ZEventRead>;

    export const ZEventCreate = REQUEST_CORE_SCHEMA('CREATE').extend({
        name: zod.string()
            .describe("The name of the event"),
        start: zod.number()
            .describe("The unix-second timestamp UTC when the event will begin"),
        end: zod.number()
            .describe("The unix-second UTC timestamp when the event finishes"),
        venues: zod.array(zod.string())
            .describe("The venues in which this event takes place"),
        attendance: zod.number()
            .describe("The anticipated attendance of this event"),
        ents: zod.string()
            .describe("The ent state of this event"),
        state: zod.string()
            .describe("The state of this event approval"),
        author: zod.string()
            .describe("The user who is running this event"),
        reserved: zod.boolean()
            .optional()
            .describe("If this space and time has been reserved for this event"),
    });
    export type EventCreate = zod.infer<typeof ZEventCreate>;

    export const ZEventUpdate = REQUEST_CORE_SCHEMA('UPDATE').extend({
        id: zod.string()
            .describe("The unique ID for this event"),
        name: zod.string()
            .optional()
            .describe("The name of the event"),
        start: zod.number()
            .optional()
            .describe("The unix-second timestamp UTC when the event will begin"),
        end: zod.number()
            .optional()
            .describe("The unix-second UTC timestamp when the event finishes"),
        venues: zod.array(zod.string())
            .optional()
            .describe("The venues in which this event takes place"),
        addVenues: zod.array(zod.string())
            .optional()
            .describe("The venues which should be added to the set"),
        removeVenues: zod.array(zod.string())
            .optional()
            .describe("The venues which should be removed from the set"),
        attendance: zod.number()
            .optional()
            .describe("The anticipated attendance of this event"),
        ents: zod.string()
            .optional()
            .describe("The ent state of this event"),
        state: zod.string()
            .optional()
            .describe("The state of this event approval"),
        author: zod.string()
            .optional()
            .describe("The user who is running this event"),
        reserved: zod.boolean()
            .optional()
            .describe("If this space and time has been reserved for this event"),
    });
    export type EventUpdate = zod.infer<typeof ZEventUpdate>;

    export const ZEventDelete = REQUEST_CORE_SCHEMA('DELETE').extend({
        id: zod.string()
            .describe("The unique identifier of this entity to remove"),
    });
    export type EventDelete = zod.infer<typeof ZEventDelete>;
    const ZEventReadResponse = RESPONSE_CORE_SCHEMA(['READ']).extend({
        result: zod.array(ZEvent)
            .describe('The array of matched entries'),
    });
    export type EventReadResponse = zod.infer<typeof ZEventReadResponse>;

    const ZEventShallowReadResponse = RESPONSE_CORE_SCHEMA(['READ']).extend({
        result: zod.array(ZEventShallow)
            .describe('The shallow array of matched entries'),
    });

    const ZEventModifyResponse = RESPONSE_CORE_SCHEMA(['READ', 'CREATE', 'UPDATE', 'DELETE']).extend({
        result: zod.array(zod.string())
            .describe('The array of matched or manipulated responses'),
    });
    export type EventModifyResponse = zod.infer<typeof ZEventModifyResponse>;

    const ZEventResponse = ZEventReadResponse.or(ZEventShallowReadResponse).or(ZEventModifyResponse)
    export type EventResponse = zod.infer<typeof ZEventResponse>;

    export type EventMessage =
        EventRead
        | EventCreate
        | EventUpdate
        | EventDelete;

    export const ZEventRequest = ZEventRead
        .or(ZEventCreate)
        .or(ZEventUpdate)
        .or(ZEventDelete);
    export type EventRequest = zod.infer<typeof ZEventRequest>;

    export class EventMessageValidator extends ZodValidator {

        constructor() {
            super(ZEventRequest);
        }

    }

    export class EventResponseValidator extends ZodValidator {

        constructor() {
            super(ZEventResponse);
        }

    }


}